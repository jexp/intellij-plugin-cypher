// This is a generated file. Not intended for manual editing.
package io.graphgeeks.intellij.plugin.cypher.psi;

import com.intellij.psi.tree.IElementType;
import com.intellij.psi.PsiElement;
import com.intellij.lang.ASTNode;
import io.graphgeeks.intellij.plugin.cypher.psi.impl.*;

public interface CypherTypes {

  IElementType ANONYMOUS_PATTERN_PART = new CypherElementType("ANONYMOUS_PATTERN_PART");
  IElementType BULK_IMPORT_QUERY = new CypherElementType("BULK_IMPORT_QUERY");
  IElementType CASE_ALTERNATIVES = new CypherElementType("CASE_ALTERNATIVES");
  IElementType CASE_EXPRESSION = new CypherElementType("CASE_EXPRESSION");
  IElementType CLAUSE = new CypherElementType("CLAUSE");
  IElementType COMMAND = new CypherElementType("COMMAND");
  IElementType CREATE = new CypherElementType("CREATE");
  IElementType CREATE_INDEX = new CypherElementType("CREATE_INDEX");
  IElementType CREATE_NODE_PROPERTY_EXISTENCE_CONSTRAINT = new CypherElementType("CREATE_NODE_PROPERTY_EXISTENCE_CONSTRAINT");
  IElementType CREATE_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT = new CypherElementType("CREATE_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT");
  IElementType CREATE_UNIQUE_CONSTRAINT = new CypherElementType("CREATE_UNIQUE_CONSTRAINT");
  IElementType DELETE = new CypherElementType("DELETE");
  IElementType DOUBLE_LITERAL = new CypherElementType("DOUBLE_LITERAL");
  IElementType DROP_INDEX = new CypherElementType("DROP_INDEX");
  IElementType DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT = new CypherElementType("DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT");
  IElementType DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT = new CypherElementType("DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT");
  IElementType DROP_UNIQUE_CONSTRAINT = new CypherElementType("DROP_UNIQUE_CONSTRAINT");
  IElementType EXPRESSION = new CypherElementType("EXPRESSION");
  IElementType FILTER_EXPRESSION = new CypherElementType("FILTER_EXPRESSION");
  IElementType FOREACH = new CypherElementType("FOREACH");
  IElementType FUNCTION_INVOCATION = new CypherElementType("FUNCTION_INVOCATION");
  IElementType FUNCTION_NAME = new CypherElementType("FUNCTION_NAME");
  IElementType HINT = new CypherElementType("HINT");
  IElementType IDENTIFIED_INDEX_LOOKUP = new CypherElementType("IDENTIFIED_INDEX_LOOKUP");
  IElementType IDENTIFIER = new CypherElementType("IDENTIFIER");
  IElementType ID_IN_COLL = new CypherElementType("ID_IN_COLL");
  IElementType INDEX_QUERY = new CypherElementType("INDEX_QUERY");
  IElementType LABEL_NAME = new CypherElementType("LABEL_NAME");
  IElementType LIMIT = new CypherElementType("LIMIT");
  IElementType LIST_COMPREHENSION = new CypherElementType("LIST_COMPREHENSION");
  IElementType LITERAL_IDS = new CypherElementType("LITERAL_IDS");
  IElementType LOAD_CSV = new CypherElementType("LOAD_CSV");
  IElementType LOAD_CSV_QUERY = new CypherElementType("LOAD_CSV_QUERY");
  IElementType LOOKUP = new CypherElementType("LOOKUP");
  IElementType MAP_LITERAL = new CypherElementType("MAP_LITERAL");
  IElementType MATCH = new CypherElementType("MATCH");
  IElementType MAYBE_IDENTIFIER = new CypherElementType("MAYBE_IDENTIFIER");
  IElementType MAYBE_NODE_LABELS = new CypherElementType("MAYBE_NODE_LABELS");
  IElementType MAYBE_PROPERTIES = new CypherElementType("MAYBE_PROPERTIES");
  IElementType MAYBE_VARIABLE_LENGTH = new CypherElementType("MAYBE_VARIABLE_LENGTH");
  IElementType MERGE = new CypherElementType("MERGE");
  IElementType MERGE_ACTION = new CypherElementType("MERGE_ACTION");
  IElementType NODE_ID_LOOKUP = new CypherElementType("NODE_ID_LOOKUP");
  IElementType NODE_INDEX_LOOKUP = new CypherElementType("NODE_INDEX_LOOKUP");
  IElementType NODE_INDEX_QUERY = new CypherElementType("NODE_INDEX_QUERY");
  IElementType NODE_LABEL = new CypherElementType("NODE_LABEL");
  IElementType NODE_LABELS = new CypherElementType("NODE_LABELS");
  IElementType NODE_LOOKUP = new CypherElementType("NODE_LOOKUP");
  IElementType NODE_PATTERN = new CypherElementType("NODE_PATTERN");
  IElementType NODE_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX = new CypherElementType("NODE_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX");
  IElementType NUMBER_LITERAL = new CypherElementType("NUMBER_LITERAL");
  IElementType ORDER = new CypherElementType("ORDER");
  IElementType PARAMETER = new CypherElementType("PARAMETER");
  IElementType PARENTHESIZED_EXPRESSION = new CypherElementType("PARENTHESIZED_EXPRESSION");
  IElementType PATTERN = new CypherElementType("PATTERN");
  IElementType PATTERN_ELEMENT = new CypherElementType("PATTERN_ELEMENT");
  IElementType PATTERN_ELEMENT_CHAIN = new CypherElementType("PATTERN_ELEMENT_CHAIN");
  IElementType PATTERN_PART = new CypherElementType("PATTERN_PART");
  IElementType PERIODIC_COMMIT_HINT = new CypherElementType("PERIODIC_COMMIT_HINT");
  IElementType PROPERTY_EXPRESSION = new CypherElementType("PROPERTY_EXPRESSION");
  IElementType PROPERTY_KEY_NAME = new CypherElementType("PROPERTY_KEY_NAME");
  IElementType PROPERTY_LOOKUP = new CypherElementType("PROPERTY_LOOKUP");
  IElementType QUERY = new CypherElementType("QUERY");
  IElementType RANGE_LITERAL = new CypherElementType("RANGE_LITERAL");
  IElementType REGULAR_QUERY = new CypherElementType("REGULAR_QUERY");
  IElementType RELATIONSHIPS_PATTERN = new CypherElementType("RELATIONSHIPS_PATTERN");
  IElementType RELATIONSHIP_DETAIL = new CypherElementType("RELATIONSHIP_DETAIL");
  IElementType RELATIONSHIP_ID_LOOKUP = new CypherElementType("RELATIONSHIP_ID_LOOKUP");
  IElementType RELATIONSHIP_INDEX_LOOKUP = new CypherElementType("RELATIONSHIP_INDEX_LOOKUP");
  IElementType RELATIONSHIP_INDEX_QUERY = new CypherElementType("RELATIONSHIP_INDEX_QUERY");
  IElementType RELATIONSHIP_LOOKUP = new CypherElementType("RELATIONSHIP_LOOKUP");
  IElementType RELATIONSHIP_PATTERN = new CypherElementType("RELATIONSHIP_PATTERN");
  IElementType RELATIONSHIP_PATTERN_SYNTAX = new CypherElementType("RELATIONSHIP_PATTERN_SYNTAX");
  IElementType RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX = new CypherElementType("RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX");
  IElementType RELATIONSHIP_TYPES = new CypherElementType("RELATIONSHIP_TYPES");
  IElementType REL_TYPE = new CypherElementType("REL_TYPE");
  IElementType REL_TYPE_NAME = new CypherElementType("REL_TYPE_NAME");
  IElementType REMOVE = new CypherElementType("REMOVE");
  IElementType REMOVE_ITEM = new CypherElementType("REMOVE_ITEM");
  IElementType RETURN = new CypherElementType("RETURN");
  IElementType RETURN_BODY = new CypherElementType("RETURN_BODY");
  IElementType RETURN_ITEM = new CypherElementType("RETURN_ITEM");
  IElementType RETURN_ITEMS = new CypherElementType("RETURN_ITEMS");
  IElementType SET_CLAUSE = new CypherElementType("SET_CLAUSE");
  IElementType SET_ITEM = new CypherElementType("SET_ITEM");
  IElementType SHORTEST_PATH_PATTERN = new CypherElementType("SHORTEST_PATH_PATTERN");
  IElementType SIGNED_INTEGER_LITERAL = new CypherElementType("SIGNED_INTEGER_LITERAL");
  IElementType SINGLE_QUERY = new CypherElementType("SINGLE_QUERY");
  IElementType SKIP = new CypherElementType("SKIP");
  IElementType SORT_ITEM = new CypherElementType("SORT_ITEM");
  IElementType START = new CypherElementType("START");
  IElementType START_POINT = new CypherElementType("START_POINT");
  IElementType STATEMENT = new CypherElementType("STATEMENT");
  IElementType STRING_LITERAL = new CypherElementType("STRING_LITERAL");
  IElementType UNION = new CypherElementType("UNION");
  IElementType UNIQUE_CONSTRAINT_SYNTAX = new CypherElementType("UNIQUE_CONSTRAINT_SYNTAX");
  IElementType UNSIGNED_INTEGER_LITERAL = new CypherElementType("UNSIGNED_INTEGER_LITERAL");
  IElementType UNWIND = new CypherElementType("UNWIND");
  IElementType WHERE = new CypherElementType("WHERE");
  IElementType WITH = new CypherElementType("WITH");

  IElementType BACTICK = new CypherTokenType("`");
  IElementType BLOCKCOMMENT = new CypherTokenType("blockComment");
  IElementType COLON = new CypherTokenType(":");
  IElementType COMMA = new CypherTokenType(",");
  IElementType DIVIDE = new CypherTokenType("/");
  IElementType DOT = new CypherTokenType(".");
  IElementType ENDRELPATTERN = new CypherTokenType("]-()");
  IElementType ENDRELPATTERNDIRECTED = new CypherTokenType("]->()");
  IElementType EQUAL = new CypherTokenType("=");
  IElementType GREATERTHANEQUALS = new CypherTokenType(">=");
  IElementType GREATHERTHEN = new CypherTokenType(">");
  IElementType INVALIDNOTEQUALS = new CypherTokenType("<>");
  IElementType K_ALL = new CypherTokenType("K_ALL");
  IElementType K_ALLSHORTESTPATHS = new CypherTokenType("K_ALLSHORTESTPATHS");
  IElementType K_AND = new CypherTokenType("K_AND");
  IElementType K_ANY = new CypherTokenType("K_ANY");
  IElementType K_AS = new CypherTokenType("K_AS");
  IElementType K_ASC = new CypherTokenType("K_ASC");
  IElementType K_ASCENDING = new CypherTokenType("K_ASCENDING");
  IElementType K_ASSERT = new CypherTokenType("K_ASSERT");
  IElementType K_ASSERT_EXISTS = new CypherTokenType("K_ASSERT_EXISTS");
  IElementType K_CASE = new CypherTokenType("K_CASE");
  IElementType K_CONSTRAINT_ON = new CypherTokenType("K_CONSTRAINT_ON");
  IElementType K_CONTAINS = new CypherTokenType("K_CONTAINS");
  IElementType K_COUNT = new CypherTokenType("K_COUNT");
  IElementType K_CREATE = new CypherTokenType("K_CREATE");
  IElementType K_CREATE_INDEX_ON = new CypherTokenType("K_CREATE_INDEX_ON");
  IElementType K_CREATE_UNIQUE = new CypherTokenType("K_CREATE_UNIQUE");
  IElementType K_DELETE = new CypherTokenType("K_DELETE");
  IElementType K_DESC = new CypherTokenType("K_DESC");
  IElementType K_DESCENDING = new CypherTokenType("K_DESCENDING");
  IElementType K_DETACH_DELETE = new CypherTokenType("K_DETACH_DELETE");
  IElementType K_DISTINCT = new CypherTokenType("K_DISTINCT");
  IElementType K_DROP = new CypherTokenType("K_DROP");
  IElementType K_DROP_INDEX_ON = new CypherTokenType("K_DROP_INDEX_ON");
  IElementType K_ELSE = new CypherTokenType("K_ELSE");
  IElementType K_END = new CypherTokenType("K_END");
  IElementType K_ENDS_WITH = new CypherTokenType("K_ENDS_WITH");
  IElementType K_EXTRACT = new CypherTokenType("K_EXTRACT");
  IElementType K_FALSE = new CypherTokenType("K_FALSE");
  IElementType K_FIELDTERMINATOR = new CypherTokenType("K_FIELDTERMINATOR");
  IElementType K_FILTER = new CypherTokenType("K_FILTER");
  IElementType K_FOREACH = new CypherTokenType("K_FOREACH");
  IElementType K_FROM = new CypherTokenType("K_FROM");
  IElementType K_IN = new CypherTokenType("K_IN");
  IElementType K_IS_NOT_NULL = new CypherTokenType("K_IS_NOT_NULL");
  IElementType K_IS_NULL = new CypherTokenType("K_IS_NULL");
  IElementType K_IS_UNIQUE = new CypherTokenType("K_IS_UNIQUE");
  IElementType K_LIMIT = new CypherTokenType("K_LIMIT");
  IElementType K_LOAD_CSV = new CypherTokenType("K_LOAD_CSV");
  IElementType K_MATCH = new CypherTokenType("K_MATCH");
  IElementType K_MERGE = new CypherTokenType("K_MERGE");
  IElementType K_NODE = new CypherTokenType("K_NODE");
  IElementType K_NONE = new CypherTokenType("K_NONE");
  IElementType K_NOT = new CypherTokenType("K_NOT");
  IElementType K_NULL = new CypherTokenType("K_NULL");
  IElementType K_ON_CREATE = new CypherTokenType("K_ON_CREATE");
  IElementType K_ON_MATCH = new CypherTokenType("K_ON_MATCH");
  IElementType K_OPTIONAL_MATCH = new CypherTokenType("K_OPTIONAL_MATCH");
  IElementType K_OR = new CypherTokenType("K_OR");
  IElementType K_ORDER_BY = new CypherTokenType("K_ORDER_BY");
  IElementType K_REDUCE = new CypherTokenType("K_REDUCE");
  IElementType K_REL = new CypherTokenType("K_REL");
  IElementType K_RELATIONSHIP = new CypherTokenType("K_RELATIONSHIP");
  IElementType K_REMOVE = new CypherTokenType("K_REMOVE");
  IElementType K_RETURN = new CypherTokenType("K_RETURN");
  IElementType K_RETURN_DISTINCT = new CypherTokenType("K_RETURN_DISTINCT");
  IElementType K_SET = new CypherTokenType("K_SET");
  IElementType K_SHORTESTPATH = new CypherTokenType("K_SHORTESTPATH");
  IElementType K_SINGLE = new CypherTokenType("K_SINGLE");
  IElementType K_SKIP = new CypherTokenType("K_SKIP");
  IElementType K_START = new CypherTokenType("K_START");
  IElementType K_STARTS_WITH = new CypherTokenType("K_STARTS_WITH");
  IElementType K_THEN = new CypherTokenType("K_THEN");
  IElementType K_TRUE = new CypherTokenType("K_TRUE");
  IElementType K_UNION = new CypherTokenType("K_UNION");
  IElementType K_UNION_ALL = new CypherTokenType("K_UNION_ALL");
  IElementType K_UNWIND = new CypherTokenType("K_UNWIND");
  IElementType K_USING_INDEX = new CypherTokenType("K_USING_INDEX");
  IElementType K_USING_JOIN_ON = new CypherTokenType("K_USING_JOIN_ON");
  IElementType K_USING_PERIODIC_COMMIT = new CypherTokenType("K_USING_PERIODIC_COMMIT");
  IElementType K_USING_SCAN = new CypherTokenType("K_USING_SCAN");
  IElementType K_WHEN = new CypherTokenType("K_WHEN");
  IElementType K_WHERE = new CypherTokenType("K_WHERE");
  IElementType K_WITH = new CypherTokenType("K_WITH");
  IElementType K_WITH_DISTINCT = new CypherTokenType("K_WITH_DISTINCT");
  IElementType K_WITH_HEADERS = new CypherTokenType("K_WITH_HEADERS");
  IElementType K_XOR = new CypherTokenType("K_XOR");
  IElementType LEFTBRACE = new CypherTokenType("(");
  IElementType LEFTCURLYBRACE = new CypherTokenType("{");
  IElementType LEFTSQUAREBRACE = new CypherTokenType("[");
  IElementType LESSTHANEQUALS = new CypherTokenType("<=");
  IElementType LESSTHEN = new CypherTokenType("<");
  IElementType LINECOMMENT = new CypherTokenType("lineComment");
  IElementType L_DECIMAL = new CypherTokenType("l_decimal");
  IElementType L_IDENTIFIER = new CypherTokenType("l_identifier");
  IElementType L_IDENTIFIER_TEXT = new CypherTokenType("l_identifier_text");
  IElementType L_INTEGER = new CypherTokenType("l_integer");
  IElementType L_SPACE = new CypherTokenType("l_space");
  IElementType L_STRING = new CypherTokenType("l_string");
  IElementType MINUS = new CypherTokenType("-");
  IElementType MODULO = new CypherTokenType("%");
  IElementType MUL = new CypherTokenType("*");
  IElementType NOTEQUALS = new CypherTokenType("!=");
  IElementType PIPE = new CypherTokenType("|");
  IElementType PLUS = new CypherTokenType("+");
  IElementType PLUSEQUALS = new CypherTokenType("+=");
  IElementType POW = new CypherTokenType("^");
  IElementType QUESTIONSIGN = new CypherTokenType("?");
  IElementType RANGE = new CypherTokenType("..");
  IElementType REGEXMATCH = new CypherTokenType("=~");
  IElementType RIGHTBRACE = new CypherTokenType(")");
  IElementType RIGHTCURLYBRACE = new CypherTokenType("}");
  IElementType RIGHTSQUAREBRACE = new CypherTokenType("]");
  IElementType SEMICOLON = new CypherTokenType(";");
  IElementType STARTRELPATTERN = new CypherTokenType("()-[");
  IElementType STARTRELPATTERNDIRECTED = new CypherTokenType("()<-[");

  class Factory {
    public static PsiElement createElement(ASTNode node) {
      IElementType type = node.getElementType();
       if (type == ANONYMOUS_PATTERN_PART) {
        return new CypherAnonymousPatternPartImpl(node);
      }
      else if (type == BULK_IMPORT_QUERY) {
        return new CypherBulkImportQueryImpl(node);
      }
      else if (type == CASE_ALTERNATIVES) {
        return new CypherCaseAlternativesImpl(node);
      }
      else if (type == CASE_EXPRESSION) {
        return new CypherCaseExpressionImpl(node);
      }
      else if (type == CLAUSE) {
        return new CypherClauseImpl(node);
      }
      else if (type == COMMAND) {
        return new CypherCommandImpl(node);
      }
      else if (type == CREATE) {
        return new CypherCreateImpl(node);
      }
      else if (type == CREATE_INDEX) {
        return new CypherCreateIndexImpl(node);
      }
      else if (type == CREATE_NODE_PROPERTY_EXISTENCE_CONSTRAINT) {
        return new CypherCreateNodePropertyExistenceConstraintImpl(node);
      }
      else if (type == CREATE_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT) {
        return new CypherCreateRelationshipPropertyExistenceConstraintImpl(node);
      }
      else if (type == CREATE_UNIQUE_CONSTRAINT) {
        return new CypherCreateUniqueConstraintImpl(node);
      }
      else if (type == DELETE) {
        return new CypherDeleteImpl(node);
      }
      else if (type == DOUBLE_LITERAL) {
        return new CypherDoubleLiteralImpl(node);
      }
      else if (type == DROP_INDEX) {
        return new CypherDropIndexImpl(node);
      }
      else if (type == DROP_NODE_PROPERTY_EXISTENCE_CONSTRAINT) {
        return new CypherDropNodePropertyExistenceConstraintImpl(node);
      }
      else if (type == DROP_RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT) {
        return new CypherDropRelationshipPropertyExistenceConstraintImpl(node);
      }
      else if (type == DROP_UNIQUE_CONSTRAINT) {
        return new CypherDropUniqueConstraintImpl(node);
      }
      else if (type == EXPRESSION) {
        return new CypherExpressionImpl(node);
      }
      else if (type == FILTER_EXPRESSION) {
        return new CypherFilterExpressionImpl(node);
      }
      else if (type == FOREACH) {
        return new CypherForeachImpl(node);
      }
      else if (type == FUNCTION_INVOCATION) {
        return new CypherFunctionInvocationImpl(node);
      }
      else if (type == FUNCTION_NAME) {
        return new CypherFunctionNameImpl(node);
      }
      else if (type == HINT) {
        return new CypherHintImpl(node);
      }
      else if (type == IDENTIFIED_INDEX_LOOKUP) {
        return new CypherIdentifiedIndexLookupImpl(node);
      }
      else if (type == IDENTIFIER) {
        return new CypherIdentifierImpl(node);
      }
      else if (type == ID_IN_COLL) {
        return new CypherIdInCollImpl(node);
      }
      else if (type == INDEX_QUERY) {
        return new CypherIndexQueryImpl(node);
      }
      else if (type == LABEL_NAME) {
        return new CypherLabelNameImpl(node);
      }
      else if (type == LIMIT) {
        return new CypherLimitImpl(node);
      }
      else if (type == LIST_COMPREHENSION) {
        return new CypherListComprehensionImpl(node);
      }
      else if (type == LITERAL_IDS) {
        return new CypherLiteralIdsImpl(node);
      }
      else if (type == LOAD_CSV) {
        return new CypherLoadCSVImpl(node);
      }
      else if (type == LOAD_CSV_QUERY) {
        return new CypherLoadCSVQueryImpl(node);
      }
      else if (type == LOOKUP) {
        return new CypherLookupImpl(node);
      }
      else if (type == MAP_LITERAL) {
        return new CypherMapLiteralImpl(node);
      }
      else if (type == MATCH) {
        return new CypherMatchImpl(node);
      }
      else if (type == MAYBE_IDENTIFIER) {
        return new CypherMaybeIdentifierImpl(node);
      }
      else if (type == MAYBE_NODE_LABELS) {
        return new CypherMaybeNodeLabelsImpl(node);
      }
      else if (type == MAYBE_PROPERTIES) {
        return new CypherMaybePropertiesImpl(node);
      }
      else if (type == MAYBE_VARIABLE_LENGTH) {
        return new CypherMaybeVariableLengthImpl(node);
      }
      else if (type == MERGE) {
        return new CypherMergeImpl(node);
      }
      else if (type == MERGE_ACTION) {
        return new CypherMergeActionImpl(node);
      }
      else if (type == NODE_ID_LOOKUP) {
        return new CypherNodeIdLookupImpl(node);
      }
      else if (type == NODE_INDEX_LOOKUP) {
        return new CypherNodeIndexLookupImpl(node);
      }
      else if (type == NODE_INDEX_QUERY) {
        return new CypherNodeIndexQueryImpl(node);
      }
      else if (type == NODE_LABEL) {
        return new CypherNodeLabelImpl(node);
      }
      else if (type == NODE_LABELS) {
        return new CypherNodeLabelsImpl(node);
      }
      else if (type == NODE_LOOKUP) {
        return new CypherNodeLookupImpl(node);
      }
      else if (type == NODE_PATTERN) {
        return new CypherNodePatternImpl(node);
      }
      else if (type == NODE_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX) {
        return new CypherNodePropertyExistenceConstraintSyntaxImpl(node);
      }
      else if (type == NUMBER_LITERAL) {
        return new CypherNumberLiteralImpl(node);
      }
      else if (type == ORDER) {
        return new CypherOrderImpl(node);
      }
      else if (type == PARAMETER) {
        return new CypherParameterImpl(node);
      }
      else if (type == PARENTHESIZED_EXPRESSION) {
        return new CypherParenthesizedExpressionImpl(node);
      }
      else if (type == PATTERN) {
        return new CypherPatternImpl(node);
      }
      else if (type == PATTERN_ELEMENT) {
        return new CypherPatternElementImpl(node);
      }
      else if (type == PATTERN_ELEMENT_CHAIN) {
        return new CypherPatternElementChainImpl(node);
      }
      else if (type == PATTERN_PART) {
        return new CypherPatternPartImpl(node);
      }
      else if (type == PERIODIC_COMMIT_HINT) {
        return new CypherPeriodicCommitHintImpl(node);
      }
      else if (type == PROPERTY_EXPRESSION) {
        return new CypherPropertyExpressionImpl(node);
      }
      else if (type == PROPERTY_KEY_NAME) {
        return new CypherPropertyKeyNameImpl(node);
      }
      else if (type == PROPERTY_LOOKUP) {
        return new CypherPropertyLookupImpl(node);
      }
      else if (type == QUERY) {
        return new CypherQueryImpl(node);
      }
      else if (type == RANGE_LITERAL) {
        return new CypherRangeLiteralImpl(node);
      }
      else if (type == REGULAR_QUERY) {
        return new CypherRegularQueryImpl(node);
      }
      else if (type == RELATIONSHIPS_PATTERN) {
        return new CypherRelationshipsPatternImpl(node);
      }
      else if (type == RELATIONSHIP_DETAIL) {
        return new CypherRelationshipDetailImpl(node);
      }
      else if (type == RELATIONSHIP_ID_LOOKUP) {
        return new CypherRelationshipIdLookupImpl(node);
      }
      else if (type == RELATIONSHIP_INDEX_LOOKUP) {
        return new CypherRelationshipIndexLookupImpl(node);
      }
      else if (type == RELATIONSHIP_INDEX_QUERY) {
        return new CypherRelationshipIndexQueryImpl(node);
      }
      else if (type == RELATIONSHIP_LOOKUP) {
        return new CypherRelationshipLookupImpl(node);
      }
      else if (type == RELATIONSHIP_PATTERN) {
        return new CypherRelationshipPatternImpl(node);
      }
      else if (type == RELATIONSHIP_PATTERN_SYNTAX) {
        return new CypherRelationshipPatternSyntaxImpl(node);
      }
      else if (type == RELATIONSHIP_PROPERTY_EXISTENCE_CONSTRAINT_SYNTAX) {
        return new CypherRelationshipPropertyExistenceConstraintSyntaxImpl(node);
      }
      else if (type == RELATIONSHIP_TYPES) {
        return new CypherRelationshipTypesImpl(node);
      }
      else if (type == REL_TYPE) {
        return new CypherRelTypeImpl(node);
      }
      else if (type == REL_TYPE_NAME) {
        return new CypherRelTypeNameImpl(node);
      }
      else if (type == REMOVE) {
        return new CypherRemoveImpl(node);
      }
      else if (type == REMOVE_ITEM) {
        return new CypherRemoveItemImpl(node);
      }
      else if (type == RETURN) {
        return new CypherReturnImpl(node);
      }
      else if (type == RETURN_BODY) {
        return new CypherReturnBodyImpl(node);
      }
      else if (type == RETURN_ITEM) {
        return new CypherReturnItemImpl(node);
      }
      else if (type == RETURN_ITEMS) {
        return new CypherReturnItemsImpl(node);
      }
      else if (type == SET_CLAUSE) {
        return new CypherSetClauseImpl(node);
      }
      else if (type == SET_ITEM) {
        return new CypherSetItemImpl(node);
      }
      else if (type == SHORTEST_PATH_PATTERN) {
        return new CypherShortestPathPatternImpl(node);
      }
      else if (type == SIGNED_INTEGER_LITERAL) {
        return new CypherSignedIntegerLiteralImpl(node);
      }
      else if (type == SINGLE_QUERY) {
        return new CypherSingleQueryImpl(node);
      }
      else if (type == SKIP) {
        return new CypherSkipImpl(node);
      }
      else if (type == SORT_ITEM) {
        return new CypherSortItemImpl(node);
      }
      else if (type == START) {
        return new CypherStartImpl(node);
      }
      else if (type == START_POINT) {
        return new CypherStartPointImpl(node);
      }
      else if (type == STATEMENT) {
        return new CypherStatementImpl(node);
      }
      else if (type == STRING_LITERAL) {
        return new CypherStringLiteralImpl(node);
      }
      else if (type == UNION) {
        return new CypherUnionImpl(node);
      }
      else if (type == UNIQUE_CONSTRAINT_SYNTAX) {
        return new CypherUniqueConstraintSyntaxImpl(node);
      }
      else if (type == UNSIGNED_INTEGER_LITERAL) {
        return new CypherUnsignedIntegerLiteralImpl(node);
      }
      else if (type == UNWIND) {
        return new CypherUnwindImpl(node);
      }
      else if (type == WHERE) {
        return new CypherWhereImpl(node);
      }
      else if (type == WITH) {
        return new CypherWithImpl(node);
      }
      throw new AssertionError("Unknown element type: " + type);
    }
  }
}
