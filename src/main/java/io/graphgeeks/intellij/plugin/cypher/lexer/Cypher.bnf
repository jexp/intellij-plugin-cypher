{
  parserClass="io.graphgeeks.intellij.plugin.cypher.parser.CypherParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cypher"
  psiImplClassSuffix="Impl"
  psiPackage="io.graphgeeks.intellij.plugin.cypher.psi"
  psiImplPackage="io.graphgeeks.intellij.plugin.cypher.psi.impl"

  elementTypeHolderClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherTypes"
  elementTypeClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherElementType"
  tokenTypeClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherTokenType"

  tokens=[
    // keywords
    K_MATCH="regexp:(M|m)(A|a)(T|t)(C|c)(H|h)"
    K_RETURN="regexp:(R|r)(E|e)(T|t)(U|u)(R|r)(N|n)"
    K_UNION="regexp:(U|u)(N|n)(I|i)(O|o)(N|n)"
    K_UNION_ALL="regexp:(U|u)(N|n)(I|i)(O|o)(N|n) (A|a)(L|l)(L|l)"
    K_LOAD_CSV="regexp:((L|l)(O|o)(A|a)(D|d) (C|c)(S|s)(V|v))"
    K_WITH_HEADERS="regexp:(W|w)(I|i)(T|t)(H|h) (H|h)(E|e)(A|a)(D|d)(E|e)(R|r)(S|s)"
    K_FROM="regexp:(F|f)(R|r)(O|o)(M|m)"
    K_AS="regexp:(A|a)(S|s)"
    K_FIELDTERMINATOR="regexp:(F|f)(I|i)(E|e)(L|l)(D|d)(T|t)(E|e)(R|r)(M|m)(I|i)(N|n)(A|a)(T|t)(O|o)(R|r)"
    K_CREATE="regexp:(C|c)(R|r)(E|e)(A|a)(T|t)(E|e)"
    K_CONSTRAINT_ON="regexp:(C|c)(O|o)(N|n)(S|s)(T|t)(R|r)(A|a)(I|i)(N|n)(T|t) (O|o)(N|n)"
    K_ASSERT="regexp:(A|a)(S|s)(S|s)(E|e)(R|r)(T|t)"
    K_IS_UNIQUE="regexp:(I|i)(S|s) (U|u)(N|n)(I|i)(Q|q)(U|u)(E|e)"
    K_ASSERT_EXISTS="regexp:(A|a)(S|s)(S|s)(E|e)(R|r)(T|t) (E|e)(X|x)(I|i)(S|s)(T|t)(S|s)"
    K_CREATE_INDEX_ON="regexp:(C|c)(R|r)(E|e)(A|a)(T|t)(E|e) (I|i)(N|n)(D|d)(E|e)(X|x) (O|o)(N|n)"
    K_DROP="regexp:(D|d)(R|r)(O|o)(P|p)"
    K_DROP_INDEX_ON="regexp:(D|d)(R|r)(O|o)(P|p) (I|i)(N|n)(D|d)(E|e)(X|x) (O|o)(N|n)"
    K_START="regexp:(S|s)(T|t)(A|a)(R|r)(T|t)"
    K_WHERE="regexp:(W|w)(H|h)(E|e)(R|r)(E|e)"
    K_NODE="regexp:(N|n)(O|o)(D|d)(E|e)"
    K_RELATIONSHIP="regexp:(R|r)(E|e)(L|l)(A|a)(T|t)(I|i)(O|o)(N|n)(S|s)(H|h)(I|i)(P|p)"
    K_REL="regexp:(R|r)(E|e)(L|l)"
    K_OPTIONAL_MATCH="regexp:(O|o)(P|p)(T|t)(I|i)(O|o)(N|n)(A|a)(L|l) (M|m)(A|a)(T|t)(C|c)(H|h)"
    K_MATCH="regexp:(M|m)(A|a)(T|t)(C|c)(H|h)"
    K_USING_INDEX="regexp:(U|u)(S|s)(I|i)(N|n)(G|g) (I|i)(N|n)(D|d)(E|e)(X|x)"
    K_USING_JOIN_ON="regexp:(U|u)(S|s)(I|i)(N|n)(G|g) (J|j)(O|o)(I|i)(N|n) (O|o)(N|n)"
    K_USING_SCAN="regexp:(U|u)(S|s)(I|i)(N|n)(G|g) (S|s)(C|c)(A|a)(N|n)"
    K_SHORTESTPATH="regexp:(S|s)(H|h)(O|o)(R|r)(T|t)(E|e)(S|s)(T|t)(P|p)(A|a)(T|t)(H|h)"
    K_ALLSHORTESTPATHS="regexp:(A|a)(L|l)(L|l)(S|s)(H|h)(O|o)(R|r)(T|t)(E|e)(S|s)(T|t)(P|p)(A|a)(T|t)(H|h)(S|s)"

    // literals
    space='regexp:\s+'
    identifier="regexp:[\w\d\$\_]+"
    identifier_text="regexp:\`[^`]+\`"
    decimal="regexp:[+-]?(([1-9]\d+)|([0-9]))\.\d+"
    integer="regexp:[+-]?(([1-9]\d+)|([0-9]))"
    unsigned_decimal_integer="regexp:\d+"
    string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    leftBrace="("
    rightBrace=")"
    leftCurlyBrace="{"
    rightCurlyBrace="}"
    leftSquareBrace="["
    rightSquareBrace="]"
    semicolon=";"
    colon=":"
    dot="."
    equal="="
    lessThen="<"
    greatherThen=">"
    plus="+"
    minus="-"
    mul="*"
    bactick="`"
    comma=","
    questionSign="?"
    pipe="|"
    range=".."

    // comments
    lineComment="regexp://.*"
    blockComment="regexp:/\*(.|\n)*\*/"
  ]
}

cypher ::= Statements *

private Statements ::= !<<eof>> Statement ';' {pin=1 recoverWhile=statement_recover}
private statement_recover ::= !(';')

/*************************
 * Statement
 */
Statement ::= Command | Query

/*************************
 * Command
 */
Command ::= CreateUniqueConstraint
          | CreateNodePropertyExistenceConstraint
          | CreateRelationshipPropertyExistenceConstraint
          | CreateIndex
          | DropUniqueConstraint
          | DropNodePropertyExistenceConstraint
          | DropRelationshipPropertyExistenceConstraint
          | DropIndex

CreateUniqueConstraint ::= K_CREATE UniqueConstraintSyntax
CreateNodePropertyExistenceConstraint ::= K_CREATE NodePropertyExistenceConstraintSyntax
CreateRelationshipPropertyExistenceConstraint ::= K_CREATE RelationshipPropertyExistenceConstraintSyntax
CreateIndex ::= K_CREATE_INDEX_ON NodeLabel "(" PropertyKeyName ")"
DropUniqueConstraint ::= K_DROP UniqueConstraintSyntax
DropNodePropertyExistenceConstraint ::= K_DROP NodePropertyExistenceConstraintSyntax
DropRelationshipPropertyExistenceConstraint ::= K_DROP RelationshipPropertyExistenceConstraintSyntax
DropIndex ::= K_DROP_INDEX_ON NodeLabel "(" PropertyKeyName ")"

UniqueConstraintSyntax ::= K_CONSTRAINT_ON "(" Identifier NodeLabel  ")" K_ASSERT PropertyExpression K_IS_UNIQUE
NodePropertyExistenceConstraintSyntax ::= K_CONSTRAINT_ON "(" Identifier NodeLabel  ")" K_ASSERT_EXISTS "(" PropertyExpression ")"
RelationshipPropertyExistenceConstraintSyntax ::= K_CONSTRAINT_ON RelationshipPatternSyntax K_ASSERT_EXISTS "(" PropertyExpression ")"
RelationshipPatternSyntax ::= ("()-[" Identifier RelType "]-()") // todo: move this to literals
      | ("()-[" Identifier RelType "]->()")
      | ("()<-[" Identifier RelType "]-()")

/*************************
 * Query
 */
Query ::= RegularQuery
      //| BulkImportQuery

/*************************
 * Clauses
 */
RegularQuery ::= SingleQuery Union*
Union ::= (K_UNION_ALL | K_UNION) SingleQuery
SingleQuery ::= Clause*
Clause ::= LoadCSV
    | Start
    | Match
//    | Unwind
//    | Merge
//    | Create
//    | SetClause
//    | Delete
//    | Remove
//    | Foreach
//    | With
//    | Return
//    | Pragma

//-- Load csv
LoadCSV ::= K_LOAD_CSV K_WITH_HEADERS? K_FROM Expression K_AS Identifier (K_FIELDTERMINATOR StringLiteral)?

//-- Start
Start ::= K_START (StartPoint ("," StartPoint)*)? Where?
StartPoint ::= Identifier "=" Lookup
Lookup ::= NodeLookup | RelationshipLookup

NodeLookup ::= K_NODE (NodeIndexLookup | NodeIndexQuery | NodeIdLookup)
NodeIndexLookup ::= IdentifiedIndexLookup
NodeIndexQuery ::= IndexQuery
NodeIdLookup ::= "(" (LiteralIds | Parameter | "*") ")"

RelationshipLookup ::= (K_RELATIONSHIP | K_REL) (RelationshipIndexLookup | RelationshipIndexQuery | RelationshipIdLookup)
RelationshipIndexLookup ::= IdentifiedIndexLookup
RelationshipIndexQuery ::= IndexQuery
RelationshipIdLookup ::= "(" (LiteralIds | Parameter | "*") ")"

IdentifiedIndexLookup ::= ":" SymbolicNameString "(" SymbolicNameString "=" (StringLiteral | Parameter) ")"
IndexQuery ::= ":" SymbolicNameString "(" (StringLiteral | Parameter) ")"
LiteralIds ::= UnsignedIntegerLiteral ("," UnsignedIntegerLiteral)*

//-- Match
Match ::= (K_OPTIONAL_MATCH | K_MATCH) Pattern Hint* Where?
Hint ::= (K_USING_INDEX Identifier NodeLabel "(" PropertyKeyName ")")
       | (K_USING_JOIN_ON Identifier ("," Identifier)*)
       | (K_USING_SCAN Identifier NodeLabel)

//-- Other
Where ::= K_WHERE Expression

/*************************
 * Patterns
 */
Pattern ::= PatternPart ("," PatternPart)*
PatternPart ::= (Identifier "=" AnonymousPatternPart) | AnonymousPatternPart
AnonymousPatternPart ::= ShortestPathPattern | PatternElement
ShortestPathPattern ::= (K_SHORTESTPATH "(" PatternElement ")")
                      | (K_ALLSHORTESTPATHS "(" PatternElement ")")
PatternElement ::= (NodePattern PatternElementChain*) | ("(" PatternElement ")") // Probably it's OK that there is "empty match" case.
PatternElementChain ::= RelationshipPattern NodePattern

RelationshipPattern ::= (LeftArrowHead Dash RelationshipDetail? Dash RightArrowHead)
                      | (LeftArrowHead Dash RelationshipDetail? Dash)
                      | (Dash RelationshipDetail? Dash RightArrowHead)
                      | (Dash RelationshipDetail? Dash)

RelationshipDetail ::=
        "[" MaybeIdentifier "?"? RelationshipTypes MaybeVariableLength MaybeProperties "]"
RelationshipTypes ::= (":" RelTypeName ("|" ":"? RelTypeName))?
MaybeVariableLength ::= ("*" RangeLiteral?)?

NodePattern ::= ("(" MaybeIdentifier MaybeNodeLabels MaybeProperties ")")
              | (MaybeIdentifier MaybeNodeLabels MaybeProperties)
MaybeNodeLabels ::= NodeLabels?

MaybeIdentifier ::= Identifier?
MaybeProperties ::= (MapLiteral | Parameter)?

/*************************
 * Expression
 */
Expression ::= "expstub"
PropertyExpression ::= "propexpstub"

/*************************
 * Literals
 */
Identifier ::= SymbolicNameString
Parameter ::= "{" (SymbolicNameString | UnsignedDecimalInteger) "}"
NodeLabel ::= ":" LabelName
StringLiteral ::= string
LabelName ::= SymbolicNameString
RelType ::= ":" RelTypeName
RelTypeName ::= SymbolicNameString
PropertyKeyName ::= SymbolicNameString
UnsignedIntegerLiteral ::= UnsignedDecimalInteger
RangeLiteral ::= (UnsignedIntegerLiteral? ".." UnsignedIntegerLiteral?) | (UnsignedIntegerLiteral)
MapLiteral ::= "{" (PropertyKeyName ":" Expression)? ("," (PropertyKeyName ":" Expression))* "}"
NodeLabels ::= NodeLabel+

/*************************
 * Base
 */
private SymbolicNameString ::=  UnescapedSymbolicNameString | EscapedSymbolicNameString
private EscapedSymbolicNameString ::= identifier_text
private UnescapedSymbolicNameString ::= identifier
private UnsignedDecimalInteger ::= unsigned_decimal_integer
private Dash ::= "-" // todo: migrate all variants
private LeftArrowHead ::= "<" // todo: migrate all variants
private RightArrowHead ::= ">" // todo: migrate all variants
