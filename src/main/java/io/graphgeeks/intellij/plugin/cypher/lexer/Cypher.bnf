{
  parserClass="io.graphgeeks.intellij.plugin.cypher.parser.CypherParser"

  extends="com.intellij.extapi.psi.ASTWrapperPsiElement"

  psiClassPrefix="Cypher"
  psiImplClassSuffix="Impl"
  psiPackage="io.graphgeeks.intellij.plugin.cypher.psi"
  psiImplPackage="io.graphgeeks.intellij.plugin.cypher.psi.impl"

  elementTypeHolderClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherTypes"
  elementTypeClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherElementType"
  tokenTypeClass="io.graphgeeks.intellij.plugin.cypher.psi.CypherTokenType"

  tokens=[
    // keywords
    K_MATCH="regexp:(M|m)(A|a)(T|t)(C|c)(H|h)"
    K_RETURN="regexp:(R|r)(E|e)(T|t)(U|u)(R|r)(N|n)"
    K_DISTINCT="regexp:(D|d)(I|i)(S|s)(T|t)(I|i)(N|n)(C|c)(T|t)"
    K_UNION="regexp:(U|u)(N|n)(I|i)(O|o)(N|n)"
    K_ALL="regexp:(A|a)(L|l)(L|l)"
    K_LOAD="regexp:(L|l)(O|o)(A|a)(D|d)"
    K_CSV="regexp:(C|c)(S|s)(V|v)"
    K_WITH="regexp:(W|w)(I|i)(T|t)(H|h)"
    K_HEADERS="regexp:(H|h)(E|e)(A|a)(D|d)(E|e)(R|r)(S|s)"
    K_FROM="regexp:(F|f)(R|r)(O|o)(M|m)"
    K_AS="regexp:(A|a)(S|s)"
    K_FIELDTERMINATOR="regexp:(F|f)(I|i)(E|e)(L|l)(D|d)(T|t)(E|e)(R|r)(M|m)(I|i)(N|n)(A|a)(T|t)(O|o)(R|r)"
    K_CREATE="regexp:(C|c)(R|r)(E|e)(A|a)(T|t)(E|e)"
    K_CONSTRAINT="regexp:(C|c)(O|o)(N|n)(S|s)(T|t)(R|r)(A|a)(I|i)(N|n)(T|t)"
    K_ON="regexp:(O|o)(N|n)"
    K_ASSERT="regexp:(A|a)(S|s)(S|s)(E|e)(R|r)(T|t)"
    K_IS="regexp:(I|i)(S|s)"
    K_UNIQUE="regexp:(U|u)(N|n)(I|i)(Q|q)(U|u)(E|e)"
    K_ASSERT="regexp:(A|a)(S|s)(S|s)(E|e)(R|r)(T|t)"
    K_EXISTS="regexp:(E|e)(X|x)(I|i)(S|s)(T|t)(S|s)"
    K_INDEX="regexp:(I|i)(N|n)(D|d)(E|e)(X|x)"
    K_DROP="regexp:(D|d)(R|r)(O|o)(P|p)"
    K_START="regexp:(S|s)(T|t)(A|a)(R|r)(T|t)"
    K_WHERE="regexp:(W|w)(H|h)(E|e)(R|r)(E|e)"
    K_NODE="regexp:(N|n)(O|o)(D|d)(E|e)"
    K_RELATIONSHIP="regexp:(R|r)(E|e)(L|l)(A|a)(T|t)(I|i)(O|o)(N|n)(S|s)(H|h)(I|i)(P|p)"
    K_REL="regexp:(R|r)(E|e)(L|l)"
    K_MATCH="regexp:(M|m)(A|a)(T|t)(C|c)(H|h)"
    K_OPTIONAL="regexp:(O|o)(P|p)(T|t)(I|i)(O|o)(N|n)(A|a)(L|l)"
    K_USING="regexp:(U|u)(S|s)(I|i)(N|n)(G|g)"
    K_JOIN="regexp:(J|j)(O|o)(I|i)(N|n)"
    K_SCAN="regexp:(S|s)(C|c)(A|a)(N|n)"
    K_SHORTESTPATH="regexp:(S|s)(H|h)(O|o)(R|r)(T|t)(E|e)(S|s)(T|t)(P|p)(A|a)(T|t)(H|h)"
    K_ALLSHORTESTPATHS="regexp:(A|a)(L|l)(L|l)(S|s)(H|h)(O|o)(R|r)(T|t)(E|e)(S|s)(T|t)(P|p)(A|a)(T|t)(H|h)(S|s)"
    K_UNWIND="regexp:(U|u)(N|n)(W|w)(I|i)(N|n)(D|d)"
    K_MERGE="regexp:(M|m)(E|e)(R|r)(G|g)(E|e)"
    K_SET="regexp:(S|s)(E|e)(T|t)"
    K_DELETE="regexp:(D|d)(E|e)(L|l)(E|e)(T|t)(E|e)"
    K_DETACH="regexp:(D|d)(E|e)(T|t)(A|a)(C|c)(H|h)"
    K_REMOVE="regexp:(R|r)(E|e)(M|m)(O|o)(V|v)(E|e)"
    K_FOREACH="regexp:(F|f)(O|o)(R|r)(E|e)(A|a)(C|c)(H|h)"
    K_IN="regexp:(I|i)(N|n)"
    K_ORDER="regexp:(O|o)(R|r)(D|d)(E|e)(R|r)"
    K_BY="regexp:(B|b)(Y|y)"
    K_DESCENDING="regexp:(D|d)(E|e)(S|s)(C|c)(E|e)(N|n)(D|d)(I|i)(N|n)(G|g)"
    K_DESC="regexp:(D|d)(E|e)(S|s)(C|c)"
    K_ASCENDING="regexp:(A|a)(S|s)(C|c)(E|e)(N|n)(D|d)(I|i)(N|n)(G|g)"
    K_ASC="regexp:(A|a)(S|s)(C|c)"
    K_SKIP="regexp:(S|s)(K|k)(I|i)(P|p)"
    K_LIMIT="regexp:(L|l)(I|i)(M|m)(I|i)(T|t)"
    K_PERIODIC="regexp:(P|p)(E|e)(R|r)(I|i)(O|o)(D|d)(I|i)(C|c)"
    K_COMMIT="regexp:(C|c)(O|o)(M|m)(M|m)(I|i)(T|t)"
    K_XOR="regexp:(X|x)(O|o)(R|r)"
    K_OR="regexp:(O|o)(R|r)"
    K_AND="regexp:(A|a)(N|n)(D|d)"
    K_NOT="regexp:(N|n)(O|o)(T|t)"
    K_STARTS="regexp:(S|s)(T|t)(A|a)(R|r)(T|t)(S|s)"
    K_ENDS="regexp:(E|e)(N|n)(D|d)(S|s)"
    K_CONTAINS="regexp:(C|c)(O|o)(N|n)(T|t)(A|a)(I|i)(N|n)(S|s)"
    K_NULL="regexp:(N|n)(U|u)(L|l)(L|l)"
    K_TRUE="regexp:(T|t)(R|r)(U|u)(E|e)"
    K_FALSE="regexp:(F|f)(A|a)(L|l)(S|s)(E|e)"
    K_COUNT="regexp:(C|c)(O|o)(U|u)(N|n)(T|t)"
    K_FILTER="regexp:(F|f)(I|i)(L|l)(T|t)(E|e)(R|r)"
    K_EXTRACT="regexp:(E|e)(X|x)(T|t)(R|r)(A|a)(C|c)(T|t)"
    K_REDUCE="regexp:(R|r)(E|e)(D|d)(U|u)(C|c)(E|e)"
    K_ALL="regexp:(A|a)(L|l)(L|l)"
    K_ANY="regexp:(A|a)(N|n)(Y|y)"
    K_NONE="regexp:(N|n)(O|o)(N|n)(E|e)"
    K_SINGLE="regexp:(S|s)(I|i)(N|n)(G|g)(L|l)(E|e)"
    K_CASE="regexp:(C|c)(A|a)(S|s)(E|e)"
    K_DISTINCT="regexp:(D|d)(I|i)(S|s)(T|t)(I|i)(N|n)(C|c)(T|t)"
    K_ELSE="regexp:(E|e)(L|l)(S|s)(E|e)"
    K_END="regexp:(E|e)(N|n)(D|d)"
    K_WHEN="regexp:(W|w)(H|h)(E|e)(N|n)"
    K_THEN="regexp:(T|t)(H|h)(E|e)(N|n)"

    // literals
    // autogenerated function regexp
    l_function="regexp:((P|p)(E|e)(R|r)(C|c)(E|e)(N|n)(T|t)(I|i)(L|l)(E|e)(D|d)(I|i)(S|s)(C|c))|((P|p)(E|e)(R|r)(C|c)(E|e)(N|n)(T|t)(I|i)(L|l)(E|e)(C|c)(O|o)(N|n)(T|t))|((R|r)(E|e)(L|l)(A|a)(T|t)(I|i)(O|o)(N|n)(S|s)(H|h)(I|i)(P|p)(S|s))|((S|s)(T|t)(A|a)(R|r)(T|t)(N|n)(O|o)(D|d)(E|e))|((S|s)(U|u)(B|b)(S|s)(T|t)(R|r)(I|i)(N|n)(G|g))|((T|t)(I|i)(M|m)(E|e)(S|s)(T|t)(A|a)(M|m)(P|p))|((H|h)(A|a)(V|v)(E|e)(R|r)(S|s)(I|i)(N|n))|((C|c)(O|o)(A|a)(L|l)(E|e)(S|s)(C|c)(E|e))|((T|t)(O|o)(S|s)(T|t)(R|r)(I|i)(N|n)(G|g))|((T|t)(O|o)(U|u)(P|p)(P|p)(E|e)(R|r))|((R|r)(A|a)(D|d)(I|i)(A|a)(N|n)(S|s))|((T|t)(O|o)(L|l)(O|o)(W|w)(E|e)(R|r))|((C|c)(O|o)(L|l)(L|l)(E|e)(C|c)(T|t))|((E|e)(N|n)(D|d)(N|n)(O|o)(D|d)(E|e))|((S|s)(T|t)(D|d)(D|d)(E|e)(V|v)(P|p))|((R|r)(E|e)(P|p)(L|l)(A|a)(C|c)(E|e))|((T|t)(O|o)(F|f)(L|l)(O|o)(A|a)(T|t))|((R|r)(E|e)(V|v)(E|e)(R|r)(S|s)(E|e))|((D|d)(E|e)(G|g)(R|r)(E|e)(E|e)(S|s))|((L|l)(E|e)(N|n)(G|g)(T|t)(H|h))|((R|r)(E|e)(D|d)(U|u)(C|c)(E|e))|((L|l)(A|a)(B|b)(E|e)(L|l)(S|s))|((S|s)(T|t)(D|d)(D|d)(E|e)(V|v))|((E|e)(X|x)(I|i)(S|s)(T|t)(S|s))|((U|u)(P|p)(P|p)(E|e)(R|r))|((R|r)(O|o)(U|u)(N|n)(D|d))|((R|r)(T|t)(R|r)(I|i)(M|m))|((F|f)(L|l)(O|o)(O|o)(R|r))|((R|r)(I|i)(G|g)(H|h)(T|t))|((S|s)(P|p)(L|l)(I|i)(T|t))|((R|r)(A|a)(N|n)(G|g)(E|e))|((L|l)(O|o)(G|g)(1|1)(0|0))|((C|c)(O|o)(U|u)(N|n)(T|t))|((L|l)(O|o)(W|w)(E|e)(R|r))|((T|t)(O|o)(I|i)(N|n)(T|t))|((A|a)(T|t)(A|a)(N|n)(2|2))|((L|l)(T|t)(R|r)(I|i)(M|m))|((N|n)(O|o)(D|d)(E|e)(S|s))|((S|s)(Q|q)(R|r)(T|t))|((A|a)(C|c)(O|o)(S|s))|((A|a)(S|s)(I|i)(N|n))|((K|k)(E|e)(Y|y)(S|s))|((R|r)(A|a)(N|n)(D|d))|((A|a)(T|t)(A|a)(N|n))|((R|r)(E|e)(L|l)(S|s))|((L|l)(E|e)(F|f)(T|t))|((L|l)(A|a)(S|s)(T|t))|((S|s)(I|i)(G|g)(N|n))|((T|t)(Y|y)(P|p)(E|e))|((H|h)(E|e)(A|a)(D|d))|((C|c)(E|e)(I|i)(L|l))|((T|t)(R|r)(I|i)(M|m))|((S|s)(I|i)(Z|z)(E|e))|((C|c)(E|e)(I|i)(L|l))|((T|t)(A|a)(I|i)(L|l))|((M|m)(I|i)(N|n))|((A|a)(B|b)(S|s))|((S|s)(U|u)(M|m))|((S|s)(T|t)(R|r))|((C|c)(O|o)(T|t))|((C|c)(O|o)(S|s))|((E|e)(X|x)(P|p))|((T|t)(A|a)(N|n))|((L|l)(O|o)(G|g))|((S|s)(I|i)(N|n))|((A|a)(V|v)(G|g))|((M|m)(A|a)(X|x))|((H|h)(A|a)(S|s))|((P|p)(I|i))|((I|i)(D|d))|((E|e))"
    l_space="regexp:([\ \t\f]|\r|\n|\r\n)+"
    l_identifier="regexp:[a-zA-Z_$][a-zA-Z_$\d]*"
    l_identifier_text="regexp:\`[^`]+\`"
    l_decimal="regexp:[+-]?(([1-9]\d+)|([0-9]))\.\d+"
    l_integer="regexp:[+-]?(([1-9]\d+)|([0-9]))"
    l_string="regexp:('([^'\\]|\\.)*'|\"([^\"\\]|\\.)*\")"

    // base
    semicolon=";"
    parenthese_open="("
    parenthese_close=")"
    bracket_CurlyOpen="{"
    bracket_CurlyClose="}"
    bracket_SquareOpen="["
    bracket_SquareClose="]"
    op_colon=":"
    op_dot="."
    op_equal="="
    op_lessThen="<"
    op_greatherThen=">"
    op_plus="+"
    op_minus="-"
    op_mul="*"
    op_bactick="`"
    op_comma=","
    op_questionSign="?"
    op_pipe="|"
    op_range=".."
    op_plusEquals="+="
    op_invalidNotEquals="<>"
    op_notEquals="!="
    op_lessThanEquals="<="
    op_greaterThanEquals=">="
    op_divide="/"
    op_modulo="%"
    op_pow="^"
    op_regexMatch="=~"
    op_startRelPattern="()-["
    op_startRelPatternDirected="()<-["
    op_endRelPattern="]-()"
    op_endRelPatternDirected="]->()"

    // comments
    lineComment="regexp://.*"
    blockComment="regexp:/\*(.|\n)*\*/"
  ]
}

cypher ::= StatementItem *

private StatementItem ::= !<<eof>> Statement ';'

/*************************
 * Statement
 */
Statement ::= Command | Query

/*************************
 * Command
 */
Command ::= CreateUniqueConstraint
          | CreateNodePropertyExistenceConstraint
          | CreateRelationshipPropertyExistenceConstraint
          | CreateIndex
          | DropUniqueConstraint
          | DropNodePropertyExistenceConstraint
          | DropRelationshipPropertyExistenceConstraint
          | DropIndex

CreateUniqueConstraint ::= K_CREATE UniqueConstraintSyntax
CreateNodePropertyExistenceConstraint ::= K_CREATE NodePropertyExistenceConstraintSyntax
CreateRelationshipPropertyExistenceConstraint ::= K_CREATE RelationshipPropertyExistenceConstraintSyntax
CreateIndex ::= K_CREATE K_INDEX K_ON NodeLabel "(" PropertyKeyName ")"
DropUniqueConstraint ::= K_DROP UniqueConstraintSyntax
DropNodePropertyExistenceConstraint ::= K_DROP NodePropertyExistenceConstraintSyntax
DropRelationshipPropertyExistenceConstraint ::= K_DROP RelationshipPropertyExistenceConstraintSyntax
DropIndex ::= K_DROP K_INDEX K_ON NodeLabel "(" PropertyKeyName ")"

UniqueConstraintSyntax ::= K_CONSTRAINT K_ON "(" Identifier NodeLabel ")" K_ASSERT PropertyExpression K_IS K_UNIQUE
NodePropertyExistenceConstraintSyntax ::= K_CONSTRAINT K_ON "(" Identifier NodeLabel ")" K_ASSERT K_EXISTS "(" PropertyExpression ")"
RelationshipPropertyExistenceConstraintSyntax ::= K_CONSTRAINT K_ON RelationshipPatternSyntax K_ASSERT K_EXISTS "(" PropertyExpression ")"
RelationshipPatternSyntax ::= ("()-[" Identifier RelType "]-()") // todo: move this to literals
      | ("()-[" Identifier RelType "]->()")
      | ("()<-[" Identifier RelType "]-()")

/*************************
 * Query
 */
Query ::= RegularQuery | BulkImportQuery // empty input is OK?

//-- RegularQuery
RegularQuery ::= SingleQuery Union*
Union ::= ((K_UNION K_ALL) | K_UNION) SingleQuery
SingleQuery ::= Clause+
Clause ::= LoadCSV
    | Start
    | Match
    | Unwind
    | Merge
    | Create
    | SetClause
    | Delete
    | Remove
    | Foreach
    | With
    | Return
    //| Pragma // todo: what the hell is this?

//-- BulkImportQuery
BulkImportQuery ::= PeriodicCommitHint LoadCSVQuery
PeriodicCommitHint ::= K_USING K_PERIODIC K_COMMIT SignedIntegerLiteral?
LoadCSVQuery ::= LoadCSV Clause*

/*************************
 * Clauses
 */
//-- Load csv
LoadCSV ::= K_LOAD K_CSV (K_WITH K_HEADERS)? K_FROM Expression K_AS Identifier (K_FIELDTERMINATOR StringLiteral)?

//-- Start
Start ::= K_START (StartPoint ("," StartPoint)*)? Where?
StartPoint ::= Identifier "=" Lookup
Lookup ::= NodeLookup | RelationshipLookup

NodeLookup ::= K_NODE (NodeIndexLookup | NodeIndexQuery | NodeIdLookup)
NodeIndexLookup ::= IdentifiedIndexLookup
NodeIndexQuery ::= IndexQuery
NodeIdLookup ::= "(" (LiteralIds | Parameter | "*") ")"

RelationshipLookup ::= (K_RELATIONSHIP | K_REL) (RelationshipIndexLookup | RelationshipIndexQuery | RelationshipIdLookup)
RelationshipIndexLookup ::= IdentifiedIndexLookup
RelationshipIndexQuery ::= IndexQuery
RelationshipIdLookup ::= "(" (LiteralIds | Parameter | "*") ")"

IdentifiedIndexLookup ::= ":" SymbolicNameString "(" SymbolicNameString "=" (StringLiteral | Parameter) ")"
IndexQuery ::= ":" SymbolicNameString "(" (StringLiteral | Parameter) ")"
LiteralIds ::= UnsignedIntegerLiteral ("," UnsignedIntegerLiteral)*

//-- Match
Match ::= ((K_OPTIONAL K_MATCH) | K_MATCH) Pattern Hint* Where?
Hint ::= (K_USING K_INDEX Identifier NodeLabel "(" PropertyKeyName ")")
       | (K_USING K_JOIN K_ON Identifier ("," Identifier)*)
       | (K_USING K_SCAN Identifier NodeLabel)

//-- Merge
Merge ::= K_MERGE PatternPart MergeAction*
MergeAction ::= (K_ON K_MATCH SetClause)
              | (K_ON K_CREATE SetClause)

//-- SetClause
SetClause ::= K_SET SetItem ("," SetItem)*
SetItem ::= (PropertyExpression "=" Expression)
          | (Identifier "=" Expression)
          | (Identifier "+=" Expression)
          | (Identifier NodeLabels)

//-- Remove
Remove ::= K_REMOVE RemoveItem ("," RemoveItem)*
RemoveItem ::= (Identifier NodeLabels) | PropertyExpression

//-- Return
With ::= (K_WITH K_DISTINCT ReturnBody Where?)
       | (K_WITH ReturnBody Where?)
Return ::= (K_RETURN K_DISTINCT ReturnBody)
         | (K_RETURN ReturnBody)
ReturnBody ::= ReturnItems Order? Skip? Limit?
ReturnItems ::= ("*" ReturnItem? ("," ReturnItem)*)
              | (ReturnItem ("," ReturnItem)*)
ReturnItem ::= (Expression K_AS Identifier) | (Expression)
Order ::= K_ORDER K_BY SortItem ("," SortItem)*
SortItem ::= (Expression (K_DESCENDING | K_DESC))
           | (Expression (K_ASCENDING | K_ASC)?)
Skip ::= K_SKIP Expression
Limit ::= K_LIMIT Expression

//-- Other
Create ::= (K_CREATE K_UNIQUE Pattern)
         | (K_CREATE Pattern)
Delete ::= (K_DELETE Expression ("," Expression)*)
         | (K_DETACH K_DELETE Expression ("," Expression)*)
Unwind ::= K_UNWIND Expression K_AS Identifier
Foreach ::= K_FOREACH "(" Identifier K_IN Expression "|" Clause+ ")"
Where ::= K_WHERE Expression

/*************************
 * Patterns
 */
Pattern ::= PatternPart ("," PatternPart)*
PatternPart ::= (Identifier "=" AnonymousPatternPart) | AnonymousPatternPart
AnonymousPatternPart ::= ShortestPathPattern | PatternElement
ShortestPathPattern ::= (K_SHORTESTPATH "(" PatternElement ")")
                      | (K_ALLSHORTESTPATHS "(" PatternElement ")")
PatternElement ::= (NodePattern PatternElementChain*) | ("(" PatternElement ")")
PatternElementChain ::= RelationshipPattern NodePattern

RelationshipPattern ::= (LeftArrowHead Dash RelationshipDetail? Dash RightArrowHead)
                      | (LeftArrowHead Dash RelationshipDetail? Dash)
                      | (Dash RelationshipDetail? Dash RightArrowHead)
                      | (Dash RelationshipDetail? Dash)

RelationshipDetail ::= "[" MaybeIdentifier "?"? RelationshipTypes MaybeVariableLength MaybeProperties "]"
RelationshipTypes ::= (":" RelTypeName ("|" ":"? RelTypeName)*)?
MaybeVariableLength ::= ("*" RangeLiteral?)?

NodePattern ::= "(" MaybeIdentifier MaybeNodeLabels MaybeProperties ")"
// disable legacy bare nodes
//| (MaybeIdentifier MaybeNodeLabels MaybeProperties)
MaybeNodeLabels ::= NodeLabels?

MaybeIdentifier ::= Identifier?
MaybeProperties ::= (MapLiteral | Parameter)?

RelationshipsPattern ::= NodePattern PatternElementChain+

/*************************
 * Expression
 */
Expression ::= Expression12
private Expression12 ::= Expression11 (K_OR Expression11)*
private Expression11 ::= Expression10 (K_XOR Expression10)*
private Expression10 ::= Expression9 (K_AND Expression9)*
private Expression9 ::= (K_NOT Expression9) | Expression8
private Expression8 ::= Expression7 PartialComparisonExpression*
private PartialComparisonExpression ::= ("=" Expression7)
                                      | ("<>" Expression7)
                                      | ("!=" Expression7)
                                      | ("<" Expression7)
                                      | (">" Expression7)
                                      | ("<=" Expression7)
                                      | (">=" Expression7)
private Expression7 ::= Expression6 (("-" Expression6) | ("+" Expression6))*
private Expression6 ::= Expression5 (("*" Expression5) | ("/" Expression5) | ("%" Expression5))*
private Expression5 ::= Expression4 ("^" Expression4)*
private Expression4 ::= Expression3 | ("-" Expression4) | ("+" Expression4)
private Expression3 ::= Expression2 (
    ("[" Expression "]")
  | ("[" Expression? ".." Expression? "]")
  | ("=~" Expression2)
  | (K_IN Expression2)
  | (K_STARTS K_WITH  Expression2)
  | (K_ENDS K_WITH  Expression2)
  | (K_CONTAINS  Expression2)
  | (K_IS K_NULL  Expression2)
  | (K_IS K_NOT K_NULL  Expression2)
)*
private Expression2 ::= Expression1 (PropertyLookup | NodeLabels)*
private Expression1 ::= NumberLiteral
              | StringLiteral
              | Parameter
              | (K_TRUE)
              | (K_FALSE)
              | (K_NULL)
              | CaseExpression
              | (K_COUNT "(" "*" ")")
              | MapLiteral
              | ListComprehension
              | ("[" Expression? ("," Expression)* "]")
              | (K_FILTER "(" FilterExpression ")")
              | (K_EXTRACT "(" FilterExpression ("|" Expression)? ")")
              | (K_REDUCE "(" Identifier "=" Expression "," IdInColl "|" Expression ")")
              | (K_ALL "(" FilterExpression ")")
              | (K_ANY "(" FilterExpression ")")
              | (K_NONE "(" FilterExpression ")")
              | (K_SINGLE "(" FilterExpression ")")
              | ShortestPathPattern
              | RelationshipsPattern
              | parenthesizedExpression
              | FunctionInvocation
              | Identifier

PropertyLookup ::= "." PropertyKeyName // todo: finish this rule, legacy part is missing
ListComprehension ::= "[" FilterExpression ("|"  Expression)? "]"
FilterExpression ::= IdInColl (K_WHERE)? Expression
IdInColl ::= Identifier K_IN Expression
parenthesizedExpression ::= "(" Expression ")"
FunctionInvocation ::= FunctionName "(" K_DISTINCT? Expression? ("," Expression)* ")"
CaseExpression ::= ((K_CASE CaseAlternatives+) | (K_CASE Expression CaseAlternatives+))
                   (K_ELSE Expression)?
                   K_END
CaseAlternatives ::= K_WHEN Expression K_THEN Expression
PropertyExpression ::= Expression1 (PropertyLookup)+

/*************************
 * Literals
 */
Identifier ::= SymbolicNameString
FunctionName ::= l_function
Parameter ::= "{" (SymbolicNameString | UnsignedDecimalInteger) "}"
NodeLabel ::= ":" LabelName
StringLiteral ::= l_string
LabelName ::= SymbolicNameString
RelType ::= ":" RelTypeName
RelTypeName ::= SymbolicNameString
PropertyKeyName ::= SymbolicNameString
RangeLiteral ::= (UnsignedIntegerLiteral? ".." UnsignedIntegerLiteral?) | (UnsignedIntegerLiteral)
MapLiteral ::= "{" (PropertyKeyName ":" Expression)? ("," PropertyKeyName ":" Expression)* "}"
NodeLabels ::= NodeLabel+
//SignedIntegerLiteral ::= HexInteger | OctalInteger | DecimalInteger // todo: this is real implementation
SignedIntegerLiteral ::= SignedDecimalInteger
UnsignedIntegerLiteral ::= UnsignedDecimalInteger
NumberLiteral ::= DoubleLiteral | SignedIntegerLiteral
DoubleLiteral ::= l_decimal // todo: make real double here

/*************************
 * Base
 */
private SymbolicNameString ::=  UnescapedSymbolicNameString | EscapedSymbolicNameString
private EscapedSymbolicNameString ::= l_identifier_text
private UnescapedSymbolicNameString ::= l_identifier
private UnsignedDecimalInteger ::= l_integer
private SignedDecimalInteger ::= l_integer
private Dash ::= "-" // todo: migrate all variants
private LeftArrowHead ::= "<" // todo: migrate all variants
private RightArrowHead ::= ">" // todo: migrate all variants
